---
output: github_document
---
# Mann-Whitney Power Analysis
#### *The Effect of Unequal Group Sizes*

This file quantifies the effect on the power of our DP Mann-Whitney test when sample group sizes are different.

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE)
```

```{r packages}
library(tidyverse)
library(rmutil)
library(latex2exp)
```

Some of the functions used in this document are used, unedited, in several other documents throughout the power analysis. We load them now---documentation for each can be found in the relevant files in the `fxns` folder.

```{r source}
source('mw/fxns/mw.R')
source('mw/fxns/gen_data.R')
source('mw/fxns/calc_stat.R')
source('mw/fxns/gen_n.R')
```

The `pwr_plot` function is a wrapper function for those previously defined. (Note that there are other `pwr_plot`s throughout this repo, which treat different inputs as variables.) The arguments are as follows:

* `sizes`: a list of any length of numeric vectors of length 2
* arguments beginning with `mean` or `sd` are all vectors of length 2. Those ending with `null` are parameters to generate the null distribution, whereas those ending with `alt` are parameters to generate the alternate distribution.
* `reps`: a numeric indicating the number of repititions to carry simulations out with
* `epsilons`: a list of any length of numeric vectors of length 2 (where c(NA, NA) indicates a public test)
* `type`: indicates which arguments to treat as variables--options of `type` are explained above.
* `alpha`: a numeric indicating the significance level

```{r pwr_plot}
pwr_plot <- function(sizes, mean_null, sd_null, mean_alt, sd_alt, reps, epsilons, alpha) {
 
# generate a new, privatized sizes vector with an entry for each 
# unique size and epsilon combination. we do not use purrr's `cross`
# function throughout the repo for clarity of argument order
  new_sizes  <-   map2(.x = rep(sizes, each = length(epsilons)), 
                       .y = rep(epsilons, length(sizes)), 
                       .f = gen_n,
                       delta = 1e-6)
   
# simulate null distributions at varying sample size and epsilon combinations.
# the piped object is a list of dataframes with length equal to 
# length(epsilons)*length(sizes) then, calculate test statistics from the null 
# distributions. the output, null_stats is a dataframe, where each row is a 
# distinct combination of epsilon & sample size, with nrow = reps
  
  null_args_list <- list(n =        new_sizes,
                         new_n =    new_sizes,
                         epsilons = rep(epsilons, times = length(sizes)))
  
  null_stats <-   pmap(.l = null_args_list,

                       .f = gen_data, 
                       mean = mean_null, sd = sd_null, reps = reps) %>%
                  map_dfc(.x = ., .f = calc_stat)

# calculate critical values for each combination of epsilon and sample size
  
  crit_vals  <-   map(null_stats, 
                      quantile, 
                      probs = alpha) %>% 
                  unlist(use.names = FALSE)
  
# simulate alternate distributions at varying sample size and epsilon 
# combinations. the piped object is a list of dataframes with length equal to 
# length(epsilons)*length(sizes). these distributions have a difference 
# in means of 1 sd. then, calculate test statistics from the alternate 
# distributions the output, alt_stats is a dataframe where each column 
# is a distinct combination of epsilon and sample size, with nrow = reps
  
  args_list <- list(n =        rep(sizes, each = length(epsilons)),
                    new_n =    new_sizes,
                    epsilons = rep(epsilons, times = length(sizes)))
  
  alt_stats <-    pmap(.l = args_list,
                       .f = gen_data, 
                       mean = mean_alt, 
                       sd = sd_alt, 
                       reps = reps) %>%
                  map_dfc(.x = ., 
                          .f = calc_stat)
  
# this is a vector of powers at given epsilon and sample size combinations 
   
  power_vector <- map2(.x = crit_vals, 
                       .y = alt_stats, 
                       .f = function(x, y) {mean(y < x)}) %>% 
                       unlist(use.names = FALSE)

# add together epsilons and make NA's "Public"  
  new_eps <- lapply(epsilons, sum) %>% unlist()
  new_eps[is.na(new_eps)] <- "Public"
  
  data_frame(epsilon = unlist(rep(new_eps, length(sizes))),
             n1 = unlist(rep(lapply(sizes, `[[`, 1), each = length(epsilons))),
             n2 = unlist(rep(lapply(sizes, `[[`, 2), each = length(epsilons))),
             n = unlist(rep(lapply(sizes, sum), each = length(epsilons))),
             n1_over_n = n1/n,
             power = power_vector)
}
```

```{r}
# create a grey-scale friendly, qualitative color scheme
colors <- c("#dd02e0", "#ece900")
```

We now make use of the `pwr_plot` function to create the relevant figure.

```{r plot}
# Make a list of sample sizes for the plot -------------------
# Make a sequence from 5 to 125 by 5
sizes_1d <- c(1, seq(5, 125, 5)) %>% as.list()
# Make the sum of every vector in the list 250
sizes <- lapply(sizes_1d, function(x) {return(c(x, 250-x))})
# Extend that list so it also has entries that add to 1000
sizes <- rbind(sizes, lapply(sizes, function(x) {4*x}))
# Just use an epsilon of 1
epsilons <- list(c(.065, .035), c(.65, .35), c(NA, NA))

# generate the plot data
mw_no_ties_uneq <- pwr_plot(sizes = sizes, 
         mean_null = c(0, 0), 
         sd_null = c(1, 1), 
         mean_alt = c(0, 1), 
         sd_alt = c(1, 1), 
         reps = 1e4, 
         epsilons = epsilons,
         alpha = .05)

# save the plot data
save(mw_no_ties_uneq, file = "mw/data/mw_no_ties_uneq.Rda")

# generate the plot
mw_no_ties_uneq_plot <- mw_no_ties_uneq %>%
  filter(epsilon != .1) %>%
  ggplot() + 
        geom_line(aes(x = n1_over_n, 
                      y = power, 
                      col = epsilon,
                      linetype = as.factor(n)),
                  size = 1.3) +
        labs(x = "m / n", y = "Power") +
        scale_color_manual(name = TeX('$\\epsilon_{tot}$'),
                           values = colors) +
        scale_linetype_discrete(name = "Total Sample \nSize n") +
        theme_minimal(base_family = "Times",
                      base_size = 24) + 
        theme(axis.line = element_line(colour = "black"))

mw_no_ties_uneq_plot

# save the plot
ggsave(filename = "mw_no_ties_uneq.png", 
       plot = mw_no_ties_uneq_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```

Note that the above data will also be used to compare to the Kruskal Wallis in the two-group case.

---
output: github_document
---
# Mann-Whitney Power Analysis
#### *Assuming No Ties*

This file analyzes the power of our DP Mann-Whitney test at several sample sizes and epsilons where samples are generated with a continuous distribution.

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE)
```

```{r packages}
library(tidyverse)
library(rmutil)
library(latex2exp)
```

Some of the functions used in this document are used, unedited, in several other documents throughout the power analysis. We load them now---documentation for each can be found in the relevant files in the `fxns` folder.

```{r source}
source('mw/fxns/mw.R')
source('mw/fxns/gen_data.R')
source('mw/fxns/calc_stat.R')
source('mw/fxns/gen_n.R')
```

One of the arguments to the function below is `type`. The `type` argument determines which inputs should be treated as variables and how to put together the plotting dataframe. Type 1 varies total sample size and total epsilon, while Type 2 varies total sample size and the proportion of epsilon allotted to either estimating the statistic or the group sample sizes.

Before defining the `pwr_plot` function, we define a set of plotting dataframe procedures for pwr_plot to carry out depending on the `type` argument.

```{r proc_1}
proc_1 <- function(sizes, reps, epsilons, power_vector)  {
  
  new_eps <- lapply(epsilons, sum, na.rm = TRUE) %>% unlist()
  new_eps[is.na(new_eps)] <- "Public"
  
  data_frame(epsilon = unlist(rep(new_eps, length(sizes))),
             sizes = unlist(rep(lapply(sizes, sum), 
                                          each = length(epsilons))),
             power = power_vector)
}
```

```{r proc_2}
proc_2 <- function(sizes, reps, epsilons, power_vector) {

  epsilon_props <- map2(map(epsilons, `[[`, 1), 
                        map(epsilons, `[[`, 2), 
                        function(x, y) {x / (x + y)})
  epsilon_props[is.na(epsilon_props)] <- "Public"
  
  data_frame(epsilon = unlist(rep(epsilon_props, length(sizes))),
                       sizes = unlist(rep(lapply(sizes, sum), each = length(epsilons))),
                       power = power_vector)
}
```


The `pwr_plot` function is a wrapper function for those previously defined. (Note that there are other `pwr_plot`s throughout this repo, which treat different inputs as variables.) The arguments are as follows:

* `sizes`: a list of any length of numeric vectors of length 2
* arguments beginning with `mean` or `sd` are all vectors of length 2. Those ending with `null` are parameters to generate the null distribution, whereas those ending with `alt` are parameters to generate the alternate distribution.
* `reps`: a numeric indicating the number of repititions to carry simulations out with
* `epsilons`: a list of any length of numeric vectors of length 2 (where c(NA, NA) indicates a public test)
* `type`: indicates which arguments to treat as variables--options of `type` are explained above.
* `alpha`: a numeric indicating the significance level

```{r pwr_plot}
pwr_plot <- function(sizes, mean_null, sd_null, mean_alt, sd_alt, reps, epsilons, type, alpha, delta) {
 
# generate a new, privatized sizes vector with an entry for each 
# unique size and epsilon combination. we do not use purrr's `cross`
# function throughout the repo for clarity of argument order
  new_sizes  <-   map2(.x = rep(sizes, each = length(epsilons)), 
                       .y = rep(epsilons, length(sizes)), 
                       .f = gen_n,
                       delta = delta)
   
# simulate null distributions at varying sample size and epsilon combinations.
# the piped object is a list of dataframes with length equal to 
# length(epsilons)*length(sizes). then, calculate test statistics from the null 
# distributions. the output, null_stats is a dataframe, where each row is a 
# distinct combination of epsilon & sample size, with nrow = reps
  
  null_args_list <- list(n =        new_sizes,
                         new_n =    new_sizes,
                         epsilons = rep(epsilons, times = length(sizes)))
  
  null_stats <-   pmap(.l = null_args_list,
                       .f = gen_data, 
                       mean = mean_null, sd = sd_null, reps = reps) %>%
                  map_dfc(.x = ., .f = calc_stat)

# calculate critical values for each combination of epsilon and sample size
  
  crit_vals  <-   map(null_stats, 
                      quantile, 
                      probs = alpha) %>% 
                  unlist(use.names = FALSE)
  
# simulate alternate distributions at varying sample size and epsilon 
# combinations. the piped object is a list of dataframes with length equal to 
# length(epsilons)*length(sizes). then, calculate test statistics from the 
# alternate distributions the output, alt_stats is a dataframe where each 
# column is a distinct combination of epsilon and sample size
  
  args_list <- list(n =        rep(sizes, each = length(epsilons)),
                    new_n =    new_sizes,
                    epsilons = rep(epsilons, times = length(sizes)))
  
  alt_stats <-    pmap(.l = args_list,
                       .f = gen_data, 
                       mean = mean_alt, 
                       sd = sd_alt, 
                       reps = reps) %>%
                  map_dfc(.x = ., .f = calc_stat)
  
# this is a vector of powers at given epsilon and sample size combinations 
   
  power_vector <- map2(.x = crit_vals, 
                       .y = alt_stats, 
                       .f = function(x, y) {mean(y < x)}) %>% 
                       unlist(use.names = FALSE)

# carry out the plotting procedure based on the type argument  
         if  (type == 1) { proc_1(sizes, reps, epsilons, power_vector) 
  } else if  (type == 2) { proc_2(sizes, reps, epsilons, power_vector) }
}
```

```{r}
# create a grey-scale friendly, qualitative color scheme
colors <- c("#000099", "#05e200", "#dd02e0", "#ece900")
```

We now make use of the `pwr_plot` function to create a variety of figures.

Type 1 varies epsilon and total sample size. This procedure is helpful for evaluating the power of the test in the most general sense if equal sample sizes can be assumed.

```{r type1}
# sizes is the desired sample sizes for the simulations. this expression gives
# a sequence of values s.t. when the log of the sample size is the x-axis 
# (as will be the case with these power curves), there will be an equal interval 
# horizontally between each point. sizes is a list of vectors length 2
sizes_1_1d <- seq(from = 1.2, to = 2.53, by = (.07))^10 %>% round() %>% as.list()
sizes_1 <- lapply(1:length(sizes_1_1d), function(x) {rep(sizes_1_1d[[x]], 2)})

# a list of common epsilons, where c(NA, NA) is the nonprivate version
epsilons_1 <- list(c(.0065, .0035), c(.065, .035), c(.65, .35), c(NA, NA))

# generate the plot data
mw_no_ties <- pwr_plot(sizes = sizes_1, 
         mean_null = c(0, 0), 
         sd_null = c(1, 1), 
         mean_alt = c(0, 1), 
         sd_alt = c(1, 1), 
         reps = 1e4, 
         epsilons = epsilons_1,
         type = 1,
         alpha = .05,
         delta = 1e-6)

# save the plot data
save(mw_no_ties, file = "mw/data/mw_no_ties.Rda")

mw_no_ties$epsilon[mw_no_ties$epsilon == 0] <- "Public"

# generate the plot
mw_no_ties_plot <- ggplot(mw_no_ties) +
                       geom_line(aes(x = sizes, 
                                     y = power, 
                                     col = epsilon),
                                 size = 1.3) +
                       labs(x = TeX('Total Sample Size $n$'), y = "Power") +
                       scale_color_manual(name = TeX('$\\epsilon$'),
                                          values = colors) + 
                       scale_x_log10() +
                       theme_minimal(base_family = "Times",
                                     base_size = 24) + 
                       theme(axis.line = element_line(colour = "black"))

mw_no_ties_plot

# save the plot
ggsave(filename = "mw_no_ties.png", 
       plot = mw_no_ties_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```

We also run the same function with epsilons chosen under the assumption that group sizes are already known and thus can be released publicly (i.e. the whole privacy budget can be devoted to estimating the statistic). The data is saved below and loaded elsewhere to compare to the Kruskal Wallis test.

```{r}
# another list of epsilons where the group sizes are assumed to be public
epsilons_pub <- list(c(NA, .1), c(NA, 1), c(NA, NA))

# generate the plot data
mw_public_n <- pwr_plot(sizes = sizes_1[1:18], 
         mean_null = c(0, 0), 
         sd_null = c(1, 1), 
         mean_alt = c(0, 1), 
         sd_alt = c(1, 1), 
         reps = 1e4, 
         epsilons = epsilons_pub,
         type = 1,
         alpha = .05,
         delta = 1e-6)

# save the plot data
save(mw_public_n, file = "mw/data/mw_public_n.Rda")
```


Type 2 varies total sample size and the proportion of epsilon allotted to estimating the statistic and group sizes. This graph is helpful for choosing the the most effective proportion of epsilon to allot to estimating group size.

```{r type2}
# sample sizes for the example of type 2
sizes_2_1d <- seq(from = 30, to = 130, by = 5) %>% as.list()
sizes_2 <- lapply(1:length(sizes_2_1d), 
                  function(x) {rep(sizes_2_1d[[x]], 2)})

# a list of epsilon combinations, each of which sum to 1, where c(NA, NA) 
# is the nonprivate version
epsilons_2 <- list(c(.55, .45), c(.65, .35), c(.75, .25), c(NA, NA))

# generate the plot data
mw_eps_allotment <- pwr_plot(sizes = sizes_2, 
         mean_null = c(0, 0), 
         sd_null = c(1, 1), 
         mean_alt = c(0, 1), 
         sd_alt = c(1, 1), 
         reps = 1e4, 
         epsilons = epsilons_2,
         type = 2,
         alpha = .05,
         delta = 1e-6)

# save the plot data
save(mw_eps_allotment, file = "mw/data/mw_eps_allotment.Rda")

# generate the plot
mw_eps_allotment_plot <- ggplot(mw_eps_allotment) +
                       geom_line(aes(x = sizes, 
                                     y = power, 
                                     col = as.factor(epsilon)),
                                 size = 1.3) +
                       labs(x = TeX('Total Sample Size $n$'), y = "Power") +
                       scale_color_manual(name = TeX('$\\epsilon_{m}:\\epsilon_{tot}$'),
                                          values = colors)  +
                       theme_minimal(base_family = "Times",
                                     base_size = 24) + 
                       theme(axis.line = element_line(colour = "black"))

mw_eps_allotment_plot

# save the plot
ggsave(filename = "mw_eps_allotment.png", 
       plot = mw_eps_allotment_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```

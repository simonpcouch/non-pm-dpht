---
output: github_document
---
# Mann-Whitney Power Analysis
#### *Uniformity of p-values*

This file analyzes the error rates of our DP Mann-Whitney test using quantile-quantile plots.

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, 
                      message = FALSE)
```

```{r}
library(tidyverse)
library(rmutil)
library(latex2exp)
```

Some of the functions used in this document are used, unedited, in several other documents throughout the power analysis. We load them now---documentation for each can be found in the relevant files in the `fxns` folder.

```{r source}
source('mw/fxns/mw.R')
source('mw/fxns/gen_data.R')
source('mw/fxns/calc_stat.R')
source('mw/fxns/gen_n.R')
```

The `qq_plot` function is a wrapper function for those previously defined. The arguments are as follows:

* `sizes`: a list of any length of numeric vectors of length 2
* `alphas`: a numeric indicating the significance levels
* `mean` or `sd` are vectors of length 2.
* `reps`: a numeric indicating the number of repititions to carry simulations out with
* `epsilon`: a numeric vector of length 2 (where c(NA, NA) indicates a public test)

```{r qq_plot}
qq_plot <- function(alphas, sizes, epsilon, mean, sd, reps, assume = FALSE, delta) {
 
# Calculate Critical Values -----------------------------  
  
  if (!assume) {
    # We use this procedure when we can't assume group sizes are equal when
    # generating the reference distribution, and thus need to allocate some
    # of epsilon to estimating the group sizes.
    
# generate a new, privatized sizes vector with an entry for each size
  new_sizes  <-   map(.x = sizes, 
                      .f = gen_n,
                      epsilon = epsilon,
                      delta = delta)
  } else {
    # We need a slightly different procedure when we can assume that group sizes
    # Are equal when generating the reference distribution
    
# generate a new sizes vector that assumes equal group sizes
# begin by averaging each of the group sizes given
    new_sizes <- lapply(sizes, mean)

# then, with this list of sizes, where each entry is 1 dimensional,
# repeat that element so that each entry has length 2
    for (i in 1:(length(new_sizes))) {
      new_sizes[[i]] <- c(new_sizes[[i]], new_sizes[[i]])
    }
  }

# simulate null distributions at varying sample sizes.the piped object is 
# a list of dataframes with length equal to length(sizes) then, calculate test 
#  statistics from the null distributions. the output, null_stats is a dataframe,
# where each row represents reference distributions at a given n with nrow = reps

  null_stats <-   map2(.x = new_sizes,
                       .y = new_sizes,
                       .f = gen_data, 
                       epsilon = epsilon,
                       mean = mean, 
                       sd = sd, 
                       reps = reps) %>%
                  map_dfc(.x = ., 
                          .f = calc_stat)
   
  
# calculate critical values for each combination of epsilon and sample size
# don't feed quantile a multidimensional alpha so that ordering of repeats is clear  
  
  crit_vals <- map2(.x = rep(null_stats, each = length(alphas)),
                    .y = rep(alphas, times = length(null_stats)),
                    .f = quantile) %>%
                    unlist(use.names = FALSE)
  
# Find Power for Each of Sizes -----------------------------
  
# simulate alternate distributions at varying sample sizes.
# the piped object is a list of dataframes with length equal to 
# length(sizes). then, calculate test statistics from the alternate 
# distributions. the output, alt_stats is a dataframe where each column 
# is the distribution of test statistics for a given sample size, with nrow = reps
  
  alt_stats <-    map2(.x = sizes,
                       .y = new_sizes,
                       .f = gen_data, 
                       epsilons = epsilon,
                       mean = mean, 
                       sd = sd, 
                       reps = reps) %>%
                  map_dfc(.x = ., .f = calc_stat)
  
# create a vector of powers at given epsilon and sample size combinations 
   
  power_vector <- map2(.x = crit_vals, 
                       .y = rep(alt_stats, each = length(alphas)), 
                       .f = function(x, y) {mean(y < x)}) %>% 
                       unlist(use.names = FALSE)

# make a dataframe of arguments and resulting powers    
  plot_df <- data.frame(sizes = rep(unlist(lapply(sizes, sum)),
                                    each = length(alphas)),
                        n1 = rep(unlist(lapply(sizes, '[[', 1)),
                                    each = length(alphas)),
                        m = rep(unlist(lapply(new_sizes, '[[', 1)),
                                    each = length(alphas)),
                        alphas = alphas,
                        power = power_vector)
}
```

```{r}
# create a grey-scale friendly, qualitative color scheme
colors <- c("#000099", "#05e200", "#dd02e0", "#ece900", "#cc6600")
```

We now make use of the `qq_plot` function to generate the plots. The first plot uses equal group sizes and the delta we ultimately decide to use when running our test.

```{r plot}
# make a vector of common sample sizes
sizes <- list(c(10, 10), c(50, 50), c(100, 100), c(250, 250), c(500, 500))

# generate the plot data
mw_qqplot <- qq_plot(sizes = sizes, 
                   alphas = seq(from = .01, to = .99, by = .01),
                   mean = c(0, 0), 
                   sd = c(1, 1), 
                   reps = 1e5, 
                   epsilon = c(.65, .35),
                   delta = 1e-6)

# save the plot data
save(mw_qqplot, file = "mw/data/mw_qqplot.Rda")

# check that the lowest line is where it should be--this number
# should be 1 (or close to it) if reps are sufficiently high
mean(mw_qqplot$power[mw_qqplot$n1 == 500] < mw_qqplot$alphas[mw_qqplot$n1 == 500])

# generate the plot
mw_qqplot_plot <- ggplot(mw_qqplot) +
                       geom_line(aes(x = power, 
                                     y = alphas, 
                                     col = as.factor(sizes)),
                                 size = 1.3) +
                       labs(x = "Theoretical Quantiles", y = "p-value Quantiles") +
                       scale_color_manual(name = "Total Sample \nSize n",
                                          values = colors) + 
                       theme_minimal(base_family = "Times",
                                     base_size = 24) + 
                       theme(axis.line = element_line(colour = "black"))

mw_qqplot_plot

# save the plot
ggsave(filename = "mw_qqplot.png", 
       plot = mw_qqplot_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```

We also want to consider the situation where group sizes are uneven--in this case, the type I error rate might be more susceptible to increases.

```{r plot}
# create a grey-scale friendly, qualitative color scheme
colors_alt <- c("#cc6600", "#000099", "#05e200", "#dd02e0", "#ece900")

# make a new sizes vector, where the total sample size is always
# 1000, but the group sample sizes are different
sizes2 <- list(c(500, 500), c(250, 750), c(50, 950))

# generate the plot data
mw_qqplot_uneq <- qq_plot(sizes = sizes2, 
                    alphas = c(.001, seq(from = .01, to = .99, by = .005), .999),
                    mean = c(0, 0), 
                    sd = c(1, 1), 
                    reps = 1e5, 
                    epsilon = c(.65, .35),
                    delta = 1e-6)

# save the plot data
save(mw_qqplot_uneq, file = "mw/data/mw_qqplot_uneq.Rda")

# generate the plot
mw_qqplot_uneq_plot <- mw_qqplot_uneq %>%
              mutate(prop_m = n1/sizes) %>%
              ggplot(.) +
                       geom_line(aes(x = power, 
                                     y = alphas, 
                                     col = as.factor(prop_m)),
                                 size = 1.3) +
                       labs(x = "Theoretical Quantiles", y = "p-value Quantiles") +
                       scale_color_manual(name = "m/n",
                                          values = colors_alt) + 
                       theme_minimal(base_family = "Times",
                                     base_size = 24) + 
                       theme(axis.line = element_line(colour = "black"))

mw_qqplot_uneq_plot


# save the plot
ggsave(filename = "mw_qqplot_uneq.png", 
       plot = mw_qqplot_uneq_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```

We would also like to run an experiment confirming our finding that calculating the reference distribution by assuming that the group sizes are equal, as we do with Kruskal Wallis, would inflate the type 1 error rate when group sizes are actually unequal. To do this, we introduce a variable `assume` that toggles whether or not we assume groups are of equal size when calculate the reference distribution.

```{r assume}
# generate the plot data
mw_qqplot_assume <- qq_plot(sizes = list(c(500, 500), c(450, 550), c(400, 600)), 
                    alphas = c(.0001, .001, seq(from = .01, to = .99, by = .01), .999),
                    mean = c(0, 0), 
                    sd = c(1, 1), 
                    reps = 1e5, 
                    epsilon = c(NA, 1),
                    assume = TRUE,
                    delta = 1e-6)

# save the plot data
save(mw_qqplot_assume, file = "mw/data/mw_qqplot_assume.Rda")

# generate the plot
mw_qqplot_assume_plot <- mw_qqplot_assume %>%
              mutate(prop_m = n1/sizes) %>%
              ggplot(.) +
                       geom_line(aes(x = power, 
                                     y = alphas, 
                                     col = as.factor(prop_m)),
                                 size = 1.3) +
                       labs(x = "Theoretical Quantiles", y = "p-value Quantiles") +
                       scale_color_manual(name = "m/n",
                                          values = colors_alt[3:5]) + 
                       theme_minimal(base_family = "Times",
                                     base_size = 24) + 
                       theme(axis.line = element_line(colour = "black"))


mw_qqplot_assume_plot

# save the plot
ggsave(filename = "mw_qqplot_assume.png", 
       plot = mw_qqplot_assume_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```


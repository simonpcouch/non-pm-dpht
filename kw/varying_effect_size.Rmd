---
output: github_document
---
# Kruskal-Wallis Power Analysis
#### *Assuming No Tiesâ€”Varying Effect Size*

This file implements functions to more effectively analyze the power of our DP Kruskal-Wallis test at several effect sizes.

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r packages}
library(tidyverse)
library(rmutil)
library(latex2exp)
```

Some of the functions used in this document are used, unedited, in several other documents throughout the power analysis. We load them now---documentation for each can be found in the relevant files in the `fxns` folder.

```{r}
source('kw/fxns/kw.R')
source('kw/fxns/kw_new.R')
source('kw/fxns/calc_stat.R')
source('kw/fxns/gen_data.R')
```

We now define a `pwr_plot` function that vectorizes over the arguments `mean_alt` and `epsilons`. Note that there are other `pwr_plot` functions in this repo that no not treat the same arguments as variables. The arguments of *this* `pwr_plot` are as follows. 

* `n`: A numeric vector of length x, indicating the sample size to carry out the test with.
* `epsilons`: A list of numerics (where NA indicates a public test)
* `kw_version`: A character vector: takes values "sq" (referring to the regular H statistic) or "abs" (referring to the unsquared absolute value H statistic) so that noise with the appropriate sensitivity can be generated.
* arguments beginning with `mean` and `sd` are vectors, also of length x, indicating the parameters to generate data for the alternate and null distribution for.
* `reps`: A numeric indicating the number of repititions to carry out the simulations with.
* `alpha`: A numeric indicating the significance level to carry the test out with.

```{r pwr_plot}
pwr_plot <- function(n, epsilons, kw_version, mean_null, sd_null, mean_alt, sd_alt, reps, alpha) {
  
# make a new n that assumes equal group sizes to generate the 
# reference distributon 
  null_n <- mean(n) %>% ceiling() %>% rep(., times = length(n))
  
# generate the reference distribution of null statistics for each epsilon 
# note the we're using null_n for the public test, too---this is not
# an issue because group sample sizes are equal already in our use cases
  null_stats <- map(.x = epsilons,
                    .f = gen_data,
                    n = null_n,
                    mean = mean_null,
                    sd = sd_null, 
                    reps = reps,
                    kw_version = kw_version) %>%
                map_dfc(.x = ., .f = calc_stat)
  
# calculate critical values for each epsilon  
  crit_vals  <-   map(null_stats, quantile, probs = 1 - alpha) %>% 
                  unlist(use.names = FALSE)
  
# generate an alternate distribution for each unique
# combination of epsilon and alternate mean
 alt_stats <- map2(.x = rep(mean_alt, times = length(epsilons)),
                   .y = rep(epsilons, each = length(mean_alt)),
                   .f = gen_data,
                   n = n,
                   sd = sd_alt,
                   reps = reps,
                   kw_version = kw_version) %>%
              map_dfc(.x = ., .f = calc_stat)
  
# calculate power for each row of alt_stats  
  power_vector <- map2(.x = rep(crit_vals, each = length(mean_alt)), 
                       .y = alt_stats, 
                       .f = function(x, y) {mean(y > x)}) %>% 
                       unlist(use.names = FALSE)

# find the greatest difference in means for each
# element of mean_alt
  sigma_diff <- map(mean_alt, 
                    function(x) {max(x) - min(x)}) %>% 
                unlist(use.names = FALSE) %>% abs()
  
# put together a dataframe of parameters and powers  
  plot_df <- data.frame(sigma_diff = rep(sigma_diff, times = length(epsilons)),
             epsilon = rep(unlist(epsilons), each = length(sigma_diff)),
             power = power_vector)
  
# check if there are NA's in epsilon; if so, convert to "Public" for plotting
  plot_df$epsilon[is.na(plot_df$epsilon)] <- "Public"

  plot_df
}
```

We now make use of `pwr_plot` to generate the figure in the paper that varies effect size.

```{r usage}
# simulate the plot data
kw_vary_eff_size <- pwr_plot(n = c(300, 300, 300),
         mean_alt = list(c(0, 0, .01), c(0, 0, .055), c(0, 0, .1), 
                         c(0, 0, .15), c(0, 0, .3), c(0, 0, .55), 
                         c(0, 0, 1), c(0, 0, 1.5), c(0, 0, 3)),                    
         epsilons = list(.1, 1, NA),
         kw_version = "abs",
         mean_null = c(0, 0, 0),
         sd_null = c(1, 1, 1),
         sd_alt = c(1, 1, 1),
         reps = 1e4,
         alpha = .05)

# save the plot data
save(kw_vary_eff_size, file = "kw/data/kw_vary_eff_size.Rda")

# create a greyscale-friendly, qualitative color palette
colors <- c("#000099", "#05e200", "#dd02e0", "#ece900")

# plot the data
kw_vary_eff_size_plot <- ggplot(kw_vary_eff_size) +
             geom_line(aes(x = sigma_diff, 
                           y = power, 
                           col = as.factor(epsilon)),
                       size = 1.3) +
             labs(x = TeX("Effect Size $(max(\\mu_{n}) - min(\\mu_{n}))$"), 
                  y = "Power") +
             theme_minimal(base_family = "Times", 
                           base_size = 24) +
             scale_color_manual(name = TeX("$\\epsilon$"), 
                                values = colors) +
             theme(axis.line = element_line(colour = "black")) +
             scale_x_log10()

kw_vary_eff_size_plot

# save the plot
ggsave(filename = "kw_vary_eff_size.png", 
       plot = kw_vary_eff_size_plot,
       path = "figures",
       width = 10,
       height = 6,
       units = "in")
```
